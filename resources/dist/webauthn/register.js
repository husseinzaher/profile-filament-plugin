var A=()=>{if(document.querySelector('meta[name="csrf-token"]'))return document.querySelector('meta[name="csrf-token"]').getAttribute("content");if(document.querySelector("[data-csrf]"))return document.querySelector("[data-csrf]").getAttribute("data-csrf");if(window.livewireScriptConfig.csrf??!1)return window.livewireScriptConfig.csrf;throw new Error("No CSRF token detected")},P=e=>Array.isArray(e),C=e=>typeof e=="object"&&e!==null,O=e=>C(e)&&!P(e),f=e=>typeof e=="function",h=(e,t)=>t in e;var _={hasErrors(){return Object.keys(this.$wire.__instance?.snapshot?.memo?.errors??{}).length>0},notifyPublicKeyError(){new FilamentNotification().danger().title("Error").body("We encountered a fatal error in the key generation process. Please try again later.").send()},isValidPublicKey(e,t="rpId"){return O(e)&&h(e,"challenge")&&h(e,t)},_ajaxOptions(e={}){return{method:"POST",headers:{"Content-Type":"application/json","X-Webauthn":""},body:JSON.stringify({_token:A(),...e})}}};function d(e){let t=new Uint8Array(e),n="";for(let r of t)n+=String.fromCharCode(r);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function g(e){let t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,a=t.padEnd(t.length+n,"="),r=atob(a),s=new ArrayBuffer(r.length),u=new Uint8Array(s);for(let i=0;i<r.length;i++)u[i]=r.charCodeAt(i);return s}function b(){return window?.PublicKeyCredential!==void 0&&typeof window.PublicKeyCredential=="function"}function T(e){let{id:t}=e;return{...e,id:g(t),transports:e.transports}}function N(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}var o=class extends Error{constructor({message:t,code:n,cause:a,name:r}){super(t,{cause:a}),this.name=r??a.name,this.code=n}};function D({error:e,options:t}){let{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new o({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(n.authenticatorSelection?.requireResidentKey===!0)return new o({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&n.authenticatorSelection?.userVerification==="required")return new o({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(n.authenticatorSelection?.userVerification==="required")return new o({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new o({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new o({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(r=>r.type==="public-key").length===0?new o({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new o({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){let a=window.location.hostname;if(N(a)){if(n.rp.id!==a)return new o({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new o({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new o({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new o({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}var w=class{createNewAbortSignal(){if(this.controller){let n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}let t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){let t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}},K=new w,U=["cross-platform","platform"];function v(e){if(e&&!(U.indexOf(e)<0))return e}async function S(e){let{optionsJSON:t,useAutoRegister:n=!1}=e;if(!b())throw new Error("WebAuthn is not supported in this browser");let a={...t,challenge:g(t.challenge),user:{...t.user,id:g(t.user.id)},excludeCredentials:t.excludeCredentials?.map(T)},r={};n&&(r.mediation="conditional"),r.publicKey=a,r.signal=K.createNewAbortSignal();let s;try{s=await navigator.credentials.create(r)}catch(l){throw D({error:l,options:r})}if(!s)throw new Error("Registration was not completed");let{id:u,rawId:i,response:c,type:I}=s,R;typeof c.getTransports=="function"&&(R=c.getTransports());let m;if(typeof c.getPublicKeyAlgorithm=="function")try{m=c.getPublicKeyAlgorithm()}catch(l){p("getPublicKeyAlgorithm()",l)}let y;if(typeof c.getPublicKey=="function")try{let l=c.getPublicKey();l!==null&&(y=d(l))}catch(l){p("getPublicKey()",l)}let E;if(typeof c.getAuthenticatorData=="function")try{E=d(c.getAuthenticatorData())}catch(l){p("getAuthenticatorData()",l)}return{id:u,rawId:d(i),response:{attestationObject:d(c.attestationObject),clientDataJSON:d(c.clientDataJSON),transports:R,publicKeyAlgorithm:m,publicKey:y,authenticatorData:E},type:I,clientExtensionResults:s.getClientExtensionResults(),authenticatorAttachment:v(s.authenticatorAttachment)}}function p(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}var x=({before:e=void 0,registerData:t={},registerUrl:n=void 0,publicKey:a=void 0,verifyKeyMethod:r="verifyKey"})=>({before:e,registerData:t,registerUrl:n,publicKey:a,verifyKeyMethod:r,error:null,processing:!1,browserSupportsWebAuthn:b,..._,async register(){if(this.error=null,!this.browserSupportsWebAuthn()||f(this.before)&&!await this.before.bind(this)())return;let s=this.publicKey;this.processing=!0;let u=f(this.registerData)?this.registerData():this.registerData;if(this.registerUrl){let i=await fetch(this.registerUrl,this._ajaxOptions(u));if(!i.ok)return this.processing=!1,this.notifyPublicKeyError();s=await i.json()}return this.isValidPublicKey(s,"rp")?S({optionsJSON:s}).then(i=>this.$wire.call(this.verifyKeyMethod,i)).catch(i=>this.error=i?.response?.data?.message??i).finally(()=>this.processing=!1):(this.processing=!1,this.notifyPublicKeyError())}}),j=x;export{j as default};
